#
# ファイル名: .github/workflows/run_dify_ocr.yml
# 役割: 手動実行でDify文字起こしプロセスを起動し、結果を保存・記録する
#

# ワークフローの名前。GitHubのActionsタブにこの名前が表示される。
name: Run Dify OCR and Log Workflow

# ワークフローが実行されるトリガーを定義するセクション。
on:
  # `workflow_dispatch` を指定することで、GitHubのUI（Actionsタブ）から手動でこのワークフローを実行できるようになる。
  workflow_dispatch:

# ワークフロー内で実行されるジョブに与える権限を設定するセクション。
permissions:
  # `contents: write` は、ワークフローがリポジトリのコンテンツに対して書き込み権限を持つことを意味する。
  # これにより、後続のステップで `git push` を実行できるようになる。
  contents: write

# 実行されるジョブを定義するセクション。
jobs:
  # "run-ocr-process" というIDのジョブを定義する。
  run-ocr-process:
    # このジョブを実行する仮想環境（ランナー）の種類を指定する。`ubuntu-latest` は最新のUbuntu環境を指す。
    runs-on: ubuntu-latest
    
    # ジョブ内で実行される一連のステップ（コマンドやアクション）を定義する。
    steps:
      # ステップ1: リポジトリのチェックアウト
      # ワークフローがリポジトリのコードにアクセスできるように、ランナーにリポジトリのコピーをダウンロードする。
      - name: Checkout repository
        # `actions/checkout@v4` は、リポジトリのチェックアウトを行うための公式アクション。`v4`はバージョンを示す。
        uses: actions/checkout@v4

      # ステップ2: Python環境のセットアップ
      - name: Set up Python
        # `actions/setup-python@v4` は、指定したバージョンのPython環境をセットアップするための公式アクション。
        uses: actions/setup-python@v4
        # アクションに渡すパラメータを指定するセクション。
        with:
          # 使用するPythonのバージョンを '3.11' に指定する。
          python-version: '3.11'

      # ステップ3: 依存ライブラリのインストール
      - name: Install dependencies
        # 実際に実行するコマンドを記述する。`|` を使うと複数行のコマンドを記述できる。
        run: |
          # Pythonのパッケージ管理ツールであるpip自身を最新バージョンにアップグレードする。
          python -m pip install --upgrade pip
          # requirements.txtファイルに記載されているライブラリ（例: google-api-python-clientなど）をすべてインストールする。
          pip install -r requirements.txt
      
      # ステップ4: Secretから認証ファイルを準備する
      - name: Prepare authentication files from secrets
        # このステップ内でのみ使用する環境変数を設定する。
        env:
          # GitHubリポジトリの "Settings" -> "Secrets and variables" -> "Actions" で設定した `CREDENTIALS_JSON` という名前のSecretの値を、
          # `CREDENTIALS_JSON` という環境変数に読み込む。
          CREDENTIALS_JSON: ${{ secrets.CREDENTIALS_JSON }}
          # 同様に、`TOKEN_JSON` Secretを読み込む。
          TOKEN_JSON: ${{ secrets.TOKEN_JSON }}

        # 実行するコマンド。
        run: |
          # 1. 環境変数 `$CREDENTIALS_JSON` の内容を `credentials.json` というファイルに書き出す。
          echo "$CREDENTIALS_JSON" > credentials.json
          # 2. 環境変数 `$TOKEN_JSON` の内容を `token.json` というファイルに書き出す。
          echo "$TOKEN_JSON" > token.json

          # ログにファイルが生成されたことを示すメッセージを出力する。
          echo "secretsから認証ファイルを生成しました。"

      # ステップ5: メインのPythonスクリプトを実行する
      - name: Run Dify Main Controller
        # このステップに `main_process` というIDを付与する。他のステップからこのステップの結果を参照する際に利用できる。
        id: main_process
        # `dify_main_controller.py` というPythonスクリプトを実行する。これがOCR処理の本体となる。
        run: python dify_main_controller.py
      
      # ステップ6: Markdownファイルとログファイルをアーティファクトとしてアップロードする
      # アーティファクトとは、ワークフローの実行結果として生成されたファイルを保存・共有するための仕組み。
      - name: Upload Markdown and Logs as Artifact
        # `if: always()` を指定することで、前のステップ（Run Dify Main Controller）が成功しても失敗しても、このステップは必ず実行される。
        if: always()
        # `actions/upload-artifact@v4` は、ファイルをアーティファクトとしてアップロードするための公式アクション。
        uses: actions/upload-artifact@v4
        # アクションに渡すパラメータ。
        with:
          # アップロードされるアーティファクトの束に付ける名前。
          name: dify-results-and-logs
          # アップロード対象のファイルやディレクトリのパスを指定する。
          path: |
            markdown/*.md
            dify_get_url_success.log
            dify_get_url_failure.log
          # `if-no-files-found: ignore` は、指定したパスにファイルが見つからなくてもエラーとせず、処理を続行する設定。
          if-no-files-found: ignore

      # ステップ7: Gitのユーザー情報を設定する
      # これから行うコミットが、誰によって行われたかを記録するために必要。
      - name: Configure Git for pushing logs
        run: |
          # コミットするユーザー名を "github-actions[bot]" に設定する。
          git config --global user.name "github-actions[bot]"
          # コミットするユーザーのメールアドレスを設定する。
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # ステップ8: ログファイルに変更があればコミットしてプッシュする
      - name: Commit and Push Log Files if changed
        run: |
          # コミット対象のファイル名を格納するシェル変数を初期化する。
          FILES_TO_COMMIT=""
          # `dify_get_url_success.log` ファイルが存在するかどうかをチェックする。
          if [ -f dify_get_url_success.log ]; then
            # 存在すれば、コミット対象リストに追加する。
            FILES_TO_COMMIT="$FILES_TO_COMMIT dify_get_url_success.log"
          fi
          # `dify_get_url_failure.log` ファイルが存在するかどうかをチェックする。
          if [ -f dify_get_url_failure.log ]; then
            # 存在すれば、コミット対象リストに追加する。
            FILES_TO_COMMIT="$FILES_TO_COMMIT dify_get_url_failure.log"
          fi

          # もしコミットすべきファイルが1つでもリストにあれば (`-n` は変数が空でないことをチェック)
          if [ -n "$FILES_TO_COMMIT" ]; then
            # `git add` コマンドで、リストアップされたファイルをステージング（コミット対象に）する。
            git add $FILES_TO_COMMIT
          else
            # コミット対象ファイルがなければ、メッセージを表示してこのステップを正常終了させる。
            echo "No log files found to commit."
            exit 0
          fi
          
          # `git diff --staged --quiet` はステージングエリアに変更があるかチェックするコマンド。
          # `!` は結果を反転させるので、「ステージングエリアに変更があった場合」に以下の処理を実行する。
          if ! git diff --staged --quiet; then
            # 日本標準時（JST）で現在時刻を取得し、`YYYYMMDD-HHMMSS` のフォーマットで変数に格納する。
            JST_TIMESTAMP=$(TZ=Asia/Tokyo date +'%Y%m%d-%H%M%S')
            # コミットメッセージを生成する。
            COMMIT_MESSAGE="$JST_TIMESTAMP: Update OCR logs via GitHub Actions"
            # 生成したメッセージでコミットを実行する。
            git commit -m "$COMMIT_MESSAGE"
            # コミットをリモートリポジトリ（GitHub）にプッシュする。
            git push
          else
            # 差分がない（新しいログの追記がない）場合は、その旨をメッセージで表示する。
            echo "No new log entries to commit."
          fi