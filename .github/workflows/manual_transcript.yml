# ワークフローの名前。GitHubのActionsタブにこの名前で表示される。
name: Manual Transcript Workflow

# ワークフローが実行されるきっかけ（トリガー）を定義するセクション。
on:
  # `workflow_dispatch` を指定することで、GitHubのUI（Actionsタブ）から手動でこのワークフローを実行できるようになる。
  workflow_dispatch:

# ワークフロー内で実行されるジョブに与える権限を設定するセクション。
permissions:
  # `contents: write` は、ワークフローがリポジトリのコンテンツに対して書き込み権限を持つことを意味する。
  # これにより、後続のステップでログファイルをリポジトリに `git push` できるようになる。
  contents: write

# 実行されるジョブを定義するセクション。
jobs:
  # "run-transcription" というIDのジョブを定義する。
  run-transcription:
    # このジョブを実行する仮想環境（ランナー）の種類を指定する。`ubuntu-latest` は最新のUbuntu環境を指す。
    runs-on: ubuntu-latest
    
    # ジョブ内で実行される一連のステップ（コマンドやアクション）を定義する。
    steps:
      # ステップ1: リポジトリのチェックアウト
      # ワークフローがリポジトリ内のスクリプトやファイルにアクセスできるように、ランナーにリポジトリのコピーをダウンロードする。
      - name: Checkout repository
        # `actions/checkout@v4` は、リポジトリのチェックアウトを行うための公式アクション。`v4`はバージョンを示す。
        uses: actions/checkout@v4

      # ステップ2: Python環境のセットアップ
      - name: Set up Python
        # `actions/setup-python@v4` は、指定したバージョンのPython環境をセットアップするための公式アクション。
        uses: actions/setup-python@v4
        # アクションに渡すパラメータを指定するセクション。
        with:
          # 使用するPythonのバージョンを '3.11' に指定する。
          python-version: '3.11'

      # ステップ3: Pythonの依存ライブラリをインストール
      - name: Install dependencies
        # 実際に実行するコマンドを記述する。`|` を使うと複数行のコマンドを記述できる。
        run: |
          # Pythonのパッケージ管理ツールであるpip自身を最新バージョンにアップグレードする。
          python -m pip install --upgrade pip
          # `requirements.txt` ファイルに記載されている必要なライブラリをすべてインストールする。
          pip install -r requirements.txt
      
      # ステップ4: ffmpegのインストール
      # ffmpegは動画や音声ファイルの変換・処理を行うための非常に強力なツール。
      - name: Install ffmpeg
        run: |
          # `apt-get`（Ubuntuのパッケージ管理ツール）のパッケージリストを更新する。
          sudo apt-get update
          # `-y` オプションを付けて、確認プロンプトなしでffmpegをインストールする。
          sudo apt-get install -y ffmpeg

      # --- ここからが統合された処理 ---

      # ステップ5: メイン処理の実行（ダウンロード、文字起こし等）
      - name: Run main process (Download, Transcribe, etc.)
        # このステップに `main_process` というIDを付与する。
        id: main_process
        # このステップ内でのみ使用する環境変数を設定する。
        env:
          # GitHubリポジトリの "Secrets" に登録した `CREDENTIALS_JSON` の値を、環境変数にセットする。
          CREDENTIALS_JSON: ${{ secrets.CREDENTIALS_JSON }}
          # 同様に、`TOKEN_JSON` Secretを環境変数にセットする。
          TOKEN_JSON: ${{ secrets.TOKEN_JSON }}
          # `ENV_FILE` Secret（.envファイルの中身全体）を環境変数 `ENV_FILE_CONTENT` にセットする。
          ENV_FILE_CONTENT: ${{ secrets.ENV_FILE }}
        # 実行するコマンド。
        run: |
          # 1. 環境変数 `$CREDENTIALS_JSON` の内容を `credentials.json` というファイルに書き出す。
          echo "$CREDENTIALS_JSON" > credentials.json
          # 2. 環境変数 `$TOKEN_JSON` の内容を `token.json` というファイルに書き出す。
          echo "$TOKEN_JSON" > token.json
          
          # 3. 環境変数 `$ENV_FILE_CONTENT` の内容を `.env` というファイルに書き出す。
          echo "$ENV_FILE_CONTENT" > .env

          # ログにファイルが生成されたことを示すメッセージを出力する。
          echo "secretsから認証ファイルを生成しました。"

          # デバッグのため、生成されたファイルの中身をワークフローのログに出力する。
          echo "--- DEBUG: credentials.jsonの中身を確認します ---"
          # `cat` コマンドで `credentials.json` ファイルの内容を表示する。
          cat credentials.json
          echo "--- DEBUG: credentials.jsonの確認完了 ---"
          
          echo "--- DEBUG: token.jsonの中身を確認します ---"
          # `cat` コマンドで `token.json` ファイルの内容を表示する。
          cat token.json
          echo "--- DEBUG: token.jsonの確認完了 ---"

          echo "--- DEBUG: .envの中身を確認します ---"
          # `cat` コマンドで `.env` ファイルの内容を表示する。
          cat .env
          echo "--- DEBUG: .envの確認完了 ---"

          # メインの処理を実行するPythonスクリプトを起動する。
          # このスクリプトが動画のダウンロード、音声変換、文字起こしなどの一連の処理を担う。
          python m00_main_mojiokosi.py
      
      # --- 処理ここまで ---

      # ステップ6: ログと結果をアーティファクトとしてアップロードする
      # アーティファクトは、ワークフロー実行後にファイルを確認・ダウンロードできるようにするための仕組み。
      - name: Upload logs and results as artifact
        # `if: always()` を指定することで、前のステップ（メイン処理）が成功しても失敗しても、このステップは必ず実行される。
        if: always()
        # `actions/upload-artifact@v4` は、ファイルをアーティファクトとしてアップロードするための公式アクション。
        uses: actions/upload-artifact@v4
        # アクションに渡すパラメータ。
        with:
          # アップロードされるアーティファクトの束に付ける名前。
          name: results-and-logs
          # アップロード対象のファイルやディレクトリのパスを指定する。
          path: |
            split_m4a/*.txt
            split_m4a/*.md
            processed_success.log
            processed_failure.log
      
      # ステップ7: Gitのユーザー情報を設定する
      # この後のコミットが、誰によって行われたかを記録するために必要。
      - name: Configure Git
        run: |
          # コミットするユーザー名を "github-actions[bot]" に設定する。
          git config --global user.name "github-actions[bot]"
          # コミットするユーザーのメールアドレスを設定する。
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # ステップ8: ログファイルをコミットしてプッシュする
      - name: Commit and Push Log Files
        run: |
          # コミット対象のファイル名を格納するシェル変数を初期化する。
          FILES_TO_COMMIT=""
          # `processed_success.log` ファイルが存在するかどうかをチェックする。
          if [ -f processed_success.log ]; then
            # 存在すれば、コミット対象リストに追加する。
            FILES_TO_COMMIT="$FILES_TO_COMMIT processed_success.log"
          fi
          # `processed_failure.log` ファイルが存在するかどうかをチェックする。
          if [ -f processed_failure.log ]; then
            # 存在すれば、コミット対象リストに追加する。
            FILES_TO_COMMIT="$FILES_TO_COMMIT processed_failure.log"
          fi

          # まずリモートの最新の状態を取得し、自分の変更をその上に再配置する
          # これによりコンフリクトを防ぐ
          git pull --rebase

          # もしコミットすべきファイルが1つでもリストにあれば (`-n` は変数が空でないことをチェック)
          if [ -n "$FILES_TO_COMMIT" ]; then
            # `git add` コマンドで、リストアップされたファイルをステージング（コミット対象に）する。
            git add $FILES_TO_COMMIT
          fi
          
          # `git diff --staged --quiet` はステージングエリアに変更があるかチェックするコマンド。
          # `!` は結果を反転させるので、「ステージングエリアに変更があった場合」に以下の処理を実行する。
          if ! git diff --staged --quiet; then
            # 日本標準時（JST）で現在時刻を取得し、`YYYYMMDD-HHMMSS` のフォーマットで変数に格納する。
            JST_TIMESTAMP=$(TZ=Asia/Tokyo date +'%Y%m%d-%H%M%S')
            # コミットメッセージを生成する。
            COMMIT_MESSAGE="$JST_TIMESTAMP: Update transcription logs via GitHub Actions"
            # 生成したメッセージでコミットを実行する。
            git commit -m "$COMMIT_MESSAGE"
            # コミットをリモートリポジトリ（GitHub）にプッシュする。
            git push
          else
            # 差分がない（新しいログの追記がない）場合は、その旨をメッセージで表示する。
            echo "No new log entries to commit."
          fi